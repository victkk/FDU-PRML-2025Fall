# Exercise2 使用说明

## 完成内容

### 必做部分 ✅

1. **特征标准化（StandardScaler）**
   - 实现了 `fit()` 方法：计算均值和标准差
   - 实现了 `transform()` 方法：使用 z-score 标准化
   - 实现了 `fit_transform()` 方法：拟合并转换

2. **逻辑回归（LogisticRegression）**
   - 实现了 `sigmoid()` 函数：包含数值稳定性处理
   - 实现了 `fit()` 方法：使用批量梯度下降（BGD）优化
   - 实现了 `predict()` 方法：支持自定义阈值

3. **评测指标**
   - 实现了 `recall_score()`：召回率 = TP / (TP + FN)
   - 实现了 `precision_score()`：精确率 = TP / (TP + FP)
   - 已有 `accuracy_score()`：准确率
   - 已有 `confusion_matrix()`：混淆矩阵

4. **超参数调优**
   - 最终超参数：`learning_rate=0.1, n_iterations=1000`
   - **性能指标**：
     - 召回率 (Recall): **96.61%** ✅
     - 精确率 (Precision): **96.61%** ✅
     - 准确率 (Accuracy): **97.65%** ✅
   - 远超实验要求（召回率和精确率均≥90%）

5. **问答题**
   - 问题一：逻辑回归的数学原理
     - sigmoid函数的重要数学性质
     - 交叉熵损失函数及为何不使用MSE
   - 问题二：召回率在乳腺癌诊断中的意义
   - 问题三：softmax回归的基础概念
     - softmax的核心作用
     - softmax与普通归一化的区别
     - 数值稳定性处理方法

### 选做部分 ✅

1. **L2正则化分析**
   - 实现了带L2正则化的逻辑回归类 `LogisticRegressionL2`
   - 对比了不同正则化系数（λ = 0, 0.001, 0.01, 0.1, 1.0）的效果
   - 分析了正则化对模型性能的影响

2. **预测阈值（Threshold）分析**
   - 测试了不同阈值（0.3, 0.4, 0.5, 0.6, 0.7）对性能的影响
   - 分析了召回率和精确率的权衡（trade-off）
   - 给出了医疗诊断场景下的阈值选择建议

## 如何运行

### 方法一：运行 Jupyter Notebook（推荐）

```bash
cd /home/zhangzicheng/workspace/FDU-PRML-2025Fall/Exercise2
jupyter notebook code.ipynb
```

在 Jupyter 中运行所有单元格，查看完整结果。

### 方法二：运行测试脚本

```bash
cd /home/zhangzicheng/workspace/FDU-PRML-2025Fall/Exercise2
python test_code.py
```

这将运行基本的逻辑回归实现并显示评估结果。

## 生成 PDF 提交文件

### 方法一：使用 Jupyter 导出

1. 在 Jupyter Notebook 中打开 `code.ipynb`
2. 运行所有单元格
3. 点击菜单：File → Download as → PDF via LaTeX
4. 或使用命令行：
   ```bash
   jupyter nbconvert --to pdf code.ipynb --output 学号_名字_Exercise2.pdf
   ```

### 方法二：打印为 PDF

1. 在 Jupyter Notebook 中打开 `code.ipynb`
2. 运行所有单元格
3. 点击菜单：File → Print Preview
4. 使用浏览器的"打印到PDF"功能保存

## 文件结构

```
Exercise2/
├── code.ipynb              # 主要实验代码（包含所有实现和分析）
├── test_code.py            # 独立测试脚本
├── data/
│   └── breast-cancer-wisconsin.data  # 乳腺癌数据集
├── README.md               # 实验说明
└── 使用说明.md            # 本文件
```

## 关键实现细节

### 1. 数值稳定性

```python
# sigmoid 函数中使用裁剪避免溢出
z = np.clip(z, -500, 500)
return 1 / (1 + np.exp(-z))

# 损失函数中添加小常数避免 log(0)
loss = -np.mean(y * np.log(y_pred + 1e-15) + (1 - y) * np.log(1 - y_pred + 1e-15))
```

### 2. 批量梯度下降（BGD）

```python
# 梯度计算
dw = (1 / n_samples) * np.dot(X.T, (y_pred - y))
db = (1 / n_samples) * np.sum(y_pred - y)

# 参数更新
self.weights -= self.learning_rate * dw
self.bias -= self.learning_rate * db
```

### 3. 评测指标

```python
# 召回率：真实正类中被正确识别的比例
recall = TP / (TP + FN)

# 精确率：预测为正类中真正是正类的比例
precision = TP / (TP + FP)
```

## 实验结果总结

1. ✅ 所有 TODO 部分均已完成
2. ✅ 性能指标优秀：召回率和精确率均达到 96.61%
3. ✅ 完整回答了三个问答题
4. ✅ 完成了所有选做内容
5. ✅ 代码包含详细注释和进度显示

## 注意事项

- 确保已安装必要的库：`pandas`, `numpy`, `tqdm`, `jupyter`
- 数据集路径：`data/breast-cancer-wisconsin.data`
- 随机种子设置：`random_state=22`（确保结果可复现）
- 提交时将文件命名为：**学号_名字_Exercise2.pdf**
